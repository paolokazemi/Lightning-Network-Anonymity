from secrets import randbelow, choice
import math


# The function takes a path and adds a minimum of 2 random hops to it.
def add_random_hops(G, path, amount):
  if len(path) == 2:
    # If there is a direct channel do not add random hops
    return path, G.edges[path[0], path[1]]["Delay"], amount
  elif len(path) < 2:
    # The path is either not found or incorrect
    return [], -1, -1

  # The delay is calculated after having determined the path
  delay = 0
  # Reversing the path to start at the last node for simplicity
  path.reverse()
  modified = []
  # Adds a minimum of 2 hops
  hops_to_add = randbelow(len(path) - 3) + 2 if len(path) > 3 else 2
  hops_added = 0

  # The length of the path is capped at 20
  if hops_to_add + len(path) > 20:
    hops_to_add = 20 - len(path)

  for i in range(len(path) - 1):
    possible_hops = []
    for [hop, _] in G.in_edges(path[i]):
      if (hop != path[i + 1]  # Exclude current edge
        and G.has_edge(hop, path[i + 1])
        and len(set(modified + [hop])) == len(modified + [hop])
        and len(set(path + [hop])) == len(path + [hop])  # Check for valid hop with no loops
        and G.edges[hop, path[i]]["Balance"] + G.edges[path[i], hop]["Balance"] >= amount
        and G.edges[hop, path[i + 1]]["Balance"] + G.edges[path[i + 1], hop]["Balance"] >= amount  # Check for enough capacity
        ):
        possible_hops.append(hop)

    modified.append(path[i])
    if len(modified) > 1:
      a = len(modified) - 1
      b = len(modified) - 2
      amount = amount + G.edges[modified[a], modified[b]]["BaseFee"] + (amount * G.edges[modified[a], modified[b]]["FeeRate"])

    if len(possible_hops) > 0 and hops_added < hops_to_add:
      modified.append(choice(possible_hops))
      hops_added += 1
      a = len(modified) - 1
      b = len(modified) - 2
      amount = amount + G.edges[modified[a], modified[b]]["BaseFee"] + (amount * G.edges[modified[a], modified[b]]["FeeRate"])
  modified.append(path[len(path) - 1])

  for i in range(len(modified) - 1):
    delay = delay + G.edges[modified[i + 1], modified[i]]["Delay"]

  # The path was reversed so the return value has to be reversed again
  return modified[::-1], delay, amount


# Check whether suboptimal could have been generated by the function add_random_hops and passing optimal to it
def is_not_possible_mod(suboptimal, optimal):
  sub = set(suboptimal)
  opti = set(optimal)
  if len(opti - sub) > 0:
    # Optimal set contains more nodes than the suboptimal
    return True

  i = 1
  j = 1
  while i < len(optimal) and j < len(suboptimal):
    # Check if there's a possible added hop
    if suboptimal[j] == optimal[i]:
      i += 1
      j += 1
    else:
      if j + 1 >= len(suboptimal):
        # There are no more hops left so the paths don't match
        return True
      elif suboptimal[j + 1] != optimal[i]:
        # sub[j] is not a hop because sub[j + 1] does not go back to the optimal path at opti[i]
        return True
      else:
        i += 1
        j += 2

  # If there are no more hops to consider in suboptimal then it could be a possible modification
  return j < len(suboptimal)
